#!/bin/bash
#
# Jira CLI - Self-bootstrapping standalone client
#
# Features:
# - Auto-creates venv on first run
# - Auto-creates symlink in ~/.local/bin
# - Manages server lifecycle (start/stop)
# - Routes commands to HTTP API
#
# Usage:
#   jira setup              # Explicit setup
#   jira start              # Start server (background)
#   jira stop               # Stop server
#   jira status             # Show server status
#   jira health             # Check Jira connection
#   jira help               # Show available commands
#   jira issue HMKG-123     # Get issue details
#   jira search "project = HMKG"  # Search issues
#

set -e

# === Configuration ===
SCRIPT_PATH="$(realpath "$0")"
PLUGIN_DIR="$(dirname "$(dirname "$SCRIPT_PATH")")"
JIRA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}/jira-cli"
VENV_DIR="$JIRA_HOME/.venv"
PID_FILE="$JIRA_HOME/server.pid"
LOG_FILE="$JIRA_HOME/server.log"
LOCAL_BIN="$HOME/.local/bin"
SYMLINK="$LOCAL_BIN/jira"
HOST="${JIRA_HOST:-127.0.0.1}"
PORT="${JIRA_PORT:-9200}"
BASE_URL="http://$HOST:$PORT"

# === Helper Functions ===

log() {
    echo "[jira] $*" >&2
}

# Determine HTTP method based on endpoint name
# Returns: POST, PATCH, DELETE, or GET (default)
get_method_for_endpoint() {
    local endpoint="$1"
    case "$endpoint" in
        # POST endpoints (create/add operations)
        create|comment|transition|worklog|attachment|watcher|weblink|link)
            echo "POST" ;;
        # Sprint issue operations need special handling
        sprint/*/issues)
            echo "POST" ;;
        # PATCH endpoints (update operations)
        update)
            echo "PATCH" ;;
        # DELETE endpoints
        delete)
            echo "DELETE" ;;
        # Default to GET for read operations
        *)
            echo "GET" ;;
    esac
}

# URL-encode a string using Python
urlencode() {
    python3 -c "import urllib.parse, sys; print(urllib.parse.quote(sys.argv[1], safe=''))" "$1"
}

ensure_venv() {
    if [[ ! -d "$VENV_DIR" ]]; then
        log "Creating virtual environment..."
        mkdir -p "$JIRA_HOME"
        python3 -m venv "$VENV_DIR"

        log "Installing dependencies..."
        "$VENV_DIR/bin/pip" install --quiet --upgrade pip
        "$VENV_DIR/bin/pip" install --quiet \
            fastapi uvicorn httpx atlassian-python-api rich pydantic

        # Install jira package in editable mode
        "$VENV_DIR/bin/pip" install --quiet -e "$PLUGIN_DIR"

        log "Setup complete."
    else
        # Re-install if plugin version changed (e.g. after /plugin update)
        local plugin_version installed_version
        plugin_version=$(python3 -c "import json; print(json.load(open('$PLUGIN_DIR/plugin.json'))['version'])" 2>/dev/null)
        installed_version=$("$VENV_DIR/bin/pip" show jira-cli 2>/dev/null | sed -n 's/^Version: //p')
        if [[ -n "$plugin_version" && "$plugin_version" != "$installed_version" ]]; then
            log "Upgrading jira-cli $installed_version -> $plugin_version..."
            "$VENV_DIR/bin/pip" install --quiet -e "$PLUGIN_DIR"
        fi
    fi
}

ensure_symlink() {
    if [[ ! -L "$SYMLINK" ]] || [[ "$(readlink "$SYMLINK" 2>/dev/null)" != "$SCRIPT_PATH" ]]; then
        mkdir -p "$LOCAL_BIN"
        ln -sf "$SCRIPT_PATH" "$SYMLINK"
        log "Installed: jira -> $SCRIPT_PATH"
    fi
}

is_running() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
        rm -f "$PID_FILE"
    fi
    return 1
}

wait_for_server() {
    local timeout=${1:-10}
    local max_attempts=$((timeout * 2))
    local count=0
    while [[ $count -lt $max_attempts ]]; do
        if curl -s "$BASE_URL/health" >/dev/null 2>&1; then
            return 0
        fi
        sleep 0.5
        count=$((count + 1))
    done
    return 1
}

start_server() {
    if is_running; then
        log "Server already running (PID $(cat "$PID_FILE"))"
        return 0
    fi

    ensure_venv
    ensure_symlink

    log "Starting server on $HOST:$PORT..."
    cd "$PLUGIN_DIR"

    JIRA_HOST="$HOST" JIRA_PORT="$PORT" \
        nohup "$VENV_DIR/bin/python" -m jira.main \
        > "$LOG_FILE" 2>&1 &

    local pid=$!
    echo "$pid" > "$PID_FILE"

    if wait_for_server 10; then
        log "Server started (PID $pid)"
        return 0
    else
        log "Server failed to start. Check $LOG_FILE"
        rm -f "$PID_FILE"
        return 1
    fi
}

stop_server() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            log "Stopping server (PID $pid)..."
            kill "$pid"
            rm -f "$PID_FILE"
            log "Server stopped."
            return 0
        fi
        rm -f "$PID_FILE"
    fi
    log "Server not running."
}

ensure_server() {
    if ! is_running; then
        start_server
    fi
}

# Endpoint aliases - map CLI command to actual API endpoint
# Allows: jira update PROJ-123 --summary "..." -> PATCH /jira/issue/PROJ-123
get_endpoint_alias() {
    local endpoint="$1"
    case "$endpoint" in
        update) echo "issue" ;;
        *) echo "$endpoint" ;;
    esac
}

# Convert CLI args to HTTP request
# jira issue HMKG-123 --format ai -> GET /jira/issue/HMKG-123?format=ai
route_request() {
    local endpoint="$1"
    shift

    # Resolve endpoint alias (e.g., update -> issue)
    local actual_endpoint
    actual_endpoint=$(get_endpoint_alias "$endpoint")

    local path_args=()
    local query_params=()
    local method_override=""
    local file_paths=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --file)
                file_paths+=("$2")
                shift
                ;;
            --*)
                # Query parameter: --key value or --key=value
                local key="${1#--}"
                if [[ "$key" == *"="* ]]; then
                    query_params+=("$key")
                elif [[ $# -ge 2 && ! "$2" == --* ]]; then
                    # Value exists (even if empty) and isn't another flag
                    query_params+=("$key=$2")
                    shift
                else
                    query_params+=("$key=true")
                fi
                ;;
            -X)
                method_override="$2"
                shift
                ;;
            *)
                # Positional argument (path parameter)
                path_args+=("$1")
                ;;
        esac
        shift
    done

    # Determine HTTP method: explicit override > auto-detection
    local method
    if [[ -n "$method_override" ]]; then
        method="$method_override"
    else
        method=$(get_method_for_endpoint "$endpoint")
    fi

    # Build URL path (URL-encode path parameters)
    # Use actual_endpoint for URL, but original endpoint for method detection
    local url="$BASE_URL/jira/$actual_endpoint"
    for arg in "${path_args[@]}"; do
        local encoded_arg
        encoded_arg=$(urlencode "$arg")
        url="$url/$encoded_arg"
    done

    # For POST/PATCH: split params into query (format only) and JSON body (rest)
    # For GET/DELETE: all params stay as query string
    local curl_args=(-s -w "\n%{http_code}")
    local query_string=""

    # File upload: send file paths as JSON body
    if [[ ${#file_paths[@]} -gt 0 ]]; then
        # Extract format param for query string
        for param in "${query_params[@]}"; do
            local key="${param%%=*}"
            local value="${param#*=}"
            if [[ "$key" == "format" ]]; then
                local encoded_value
                encoded_value=$(urlencode "$value")
                query_string="${key}=${encoded_value}"
            fi
        done
        if [[ -n "$query_string" ]]; then
            url="${url}?${query_string}"
        fi
        # Resolve to absolute paths and build JSON body
        local json_body
        json_body=$(python3 -c "
import json, sys, os
print(json.dumps({'files': [os.path.abspath(f) for f in sys.argv[1:]]}))
" "${file_paths[@]}")
        curl_args+=(-X POST -H "Content-Type: application/json" -d "$json_body")
    elif [[ "$method" == "POST" || "$method" == "PATCH" ]] && [[ ${#query_params[@]} -gt 0 ]]; then
        local body_params=()
        for param in "${query_params[@]}"; do
            local key="${param%%=*}"
            local value="${param#*=}"
            if [[ "$key" == "format" ]]; then
                local encoded_value
                encoded_value=$(urlencode "$value")
                if [[ -n "$query_string" ]]; then
                    query_string="${query_string}&${key}=${encoded_value}"
                else
                    query_string="${key}=${encoded_value}"
                fi
            else
                body_params+=("$key" "$value")
            fi
        done

        if [[ -n "$query_string" ]]; then
            url="${url}?${query_string}"
        fi

        # Build JSON body from params using python3
        if [[ ${#body_params[@]} -gt 0 ]]; then
            local json_body
            json_body=$(python3 -c "
import json, sys
args = sys.argv[1:]
d = {}
for i in range(0, len(args), 2):
    d[args[i]] = args[i+1]
print(json.dumps(d))
" "${body_params[@]}")
            curl_args+=(-X "$method" -H "Content-Type: application/json" -d "$json_body")
        else
            curl_args+=(-X "$method")
        fi
    else
        # GET/DELETE or no params: use query string
        if [[ ${#query_params[@]} -gt 0 ]]; then
            for param in "${query_params[@]}"; do
                local key="${param%%=*}"
                local value="${param#*=}"
                local encoded_value
                encoded_value=$(urlencode "$value")
                if [[ -n "$query_string" ]]; then
                    query_string="${query_string}&${key}=${encoded_value}"
                else
                    query_string="${key}=${encoded_value}"
                fi
            done
            url="${url}?${query_string}"
        fi

        if [[ "$method" != "GET" ]]; then
            curl_args+=(-X "$method")
        fi
    fi

    curl_args+=("$url")

    # Make request
    local response
    response=$(curl "${curl_args[@]}")

    # Extract body and status
    local http_code
    http_code=$(echo "$response" | tail -n1)
    local body
    body=$(echo "$response" | head -n-1)

    # Output response
    echo "$body"

    # Return appropriate exit code
    if [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
        return 0
    else
        return 1
    fi
}

# === Main Command Router ===

case "${1:-help}" in
    setup)
        log "Setting up Jira CLI..."
        ensure_venv
        ensure_symlink
        log "Done. Run 'jira health' to verify connection."
        ;;

    start)
        start_server
        ;;

    stop)
        stop_server
        ;;

    restart)
        stop_server
        sleep 1
        start_server
        ;;

    status)
        # If no additional args, show server status
        # If args provided, route to /jira/status/{name} endpoint
        if [[ $# -eq 1 ]]; then
            if is_running; then
                echo "Server running (PID $(cat "$PID_FILE")) on $BASE_URL"
                curl -s "$BASE_URL/health" | python3 -m json.tool 2>/dev/null || true
            else
                echo "Server not running"
                exit 1
            fi
        else
            ensure_server
            route_request "$@"
        fi
        ;;

    logs)
        if [[ -f "$LOG_FILE" ]]; then
            tail -f "$LOG_FILE"
        else
            echo "No logs found at $LOG_FILE"
        fi
        ;;

    help|--help|-h)
        ensure_server
        route_request "help" "${@:2}"
        ;;

    *)
        # Auto-start server and route command
        ensure_server
        route_request "$@"
        ;;
esac
